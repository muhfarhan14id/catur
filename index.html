<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catur Pro - Strategis Advisor</title>
    <style>
        :root {
            --bg-color: #121212;
            --board-light: #ebecd0;
            --board-dark: #779556;
            --highlight-move: rgba(255, 255, 0, 0.5);
            --highlight-last: rgba(155, 199, 0, 0.4);
            --highlight-check: rgba(255, 0, 0, 0.8);
            --highlight-threat: rgba(255, 0, 0, 0.3);
            --highlight-legal: rgba(0, 0, 0, 0.1);
            --text-color: #e0e0e0;
            --ui-bg: #1e1e1e;
            --accent: #00bcd4;
            --danger: #ff5252;
            --success: #4caf50;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            padding: 20px;
            min-height: 100vh;
        }

        .main-layout {
            display: grid;
            grid-template-columns: auto 400px;
            gap: 20px;
            max-width: 1200px;
            width: 100%;
        }

        /* Board Section */
        .board-section { display: flex; flex-direction: column; align-items: center; }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 560px;
            height: 560px;
            border: 5px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.7);
            position: relative;
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }

        .square.light { background-color: var(--board-light); }
        .square.dark { background-color: var(--board-dark); }
        .square.selected { background-color: var(--highlight-move); }
        .square.last-move { background-color: var(--highlight-last); }
        .square.check { background-color: var(--highlight-check); border-radius: 50%; }
        .square.threatened { box-shadow: inset 0 0 15px var(--danger); }

        .piece { width: 90%; height: 90%; z-index: 5; pointer-events: none; }
        .piece svg { width: 100%; height: 100%; }

        .legal-dot {
            width: 20px;
            height: 20px;
            background: var(--highlight-legal);
            border-radius: 50%;
            z-index: 2;
        }

        /* Advisor Section */
        .advisor-panel {
            background: var(--ui-bg);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border: 1px solid #333;
            max-height: 850px;
            overflow-y: auto;
        }

        .advisor-header {
            border-bottom: 2px solid var(--accent);
            padding-bottom: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .eval-bar-container {
            height: 10px;
            background: #444;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
            display: flex;
        }
        #eval-white { background: white; transition: width 0.5s; }
        #eval-black { background: #111; transition: width 0.5s; }

        .threat-list {
            background: rgba(255, 82, 82, 0.1);
            border-left: 4px solid var(--danger);
            padding: 10px;
            border-radius: 4px;
        }

        .best-moves {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .move-suggestion {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #444;
            cursor: pointer;
            transition: 0.2s;
        }
        .move-suggestion:hover { background: #333; border-color: var(--accent); }
        .move-rank { font-weight: bold; color: var(--accent); margin-right: 8px; }

        .ui-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-primary { background: var(--accent); color: #000; }
        .btn-danger { background: var(--danger); color: #fff; }
        button:hover { opacity: 0.8; }

        .status-badge {
            background: #111;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9rem;
        }

        /* Mobile Adjustments */
        @media (max-width: 1000px) {
            .main-layout { grid-template-columns: 1fr; }
            .board { width: 95vw; height: 95vw; }
            .square { width: auto; height: auto; }
            .advisor-panel { max-height: none; }
        }

        #promotion-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2b2b2b;
            padding: 20px;
            border-radius: 12px;
            z-index: 1000;
            border: 2px solid var(--accent);
        }
    </style>
</head>
<body>

    <div class="main-layout">
        <!-- Bagian Kiri: Papan -->
        <div class="board-section">
            <div id="status-display" class="status-badge" style="width: 100%; margin-bottom: 10px;">Giliran: Putih</div>
            <div id="board" class="board"></div>
            <div class="ui-controls" style="width: 100%; margin-top: 15px;">
                <button class="btn-primary" onclick="resetGame()">Game Baru</button>
                <button style="background: #555; color: white;" onclick="undoMove()">Batal Langkah</button>
            </div>
        </div>

        <!-- Bagian Kanan: Penasihat Strategis -->
        <div class="advisor-panel">
            <div class="advisor-header">
                <span>üõ°Ô∏è Penasihat Strategis AI</span>
            </div>
            
            <div>
                <label style="font-size: 0.8rem; color: #888;">Evaluasi Posisi</label>
                <div class="eval-bar-container">
                    <div id="eval-white" style="width: 50%;"></div>
                    <div id="eval-black" style="width: 50%;"></div>
                </div>
                <div id="eval-text" style="text-align: center; font-size: 0.8rem;">Imbang (0.0)</div>
            </div>

            <div id="threat-container" class="threat-list">
                <strong>‚ö†Ô∏è Ancaman AI:</strong>
                <div id="threat-content" style="font-size: 0.85rem; margin-top: 5px;">Tidak ada ancaman langsung.</div>
            </div>

            <div class="best-moves">
                <strong>üí° Saran Langkah Terbaik:</strong>
                <div id="suggestion-content" style="font-size: 0.85rem;">Menganalisis...</div>
            </div>

            <div id="ai-prediction" style="background: #111; padding: 10px; border-radius: 6px; font-size: 0.85rem;">
                <strong>üîÆ Prediksi Balasan AI:</strong>
                <div id="prediction-content" style="color: #aaa; margin-top: 5px;">Menunggu langkah Anda.</div>
            </div>

            <div style="margin-top: auto; font-size: 0.75rem; color: #666; font-style: italic;">
                * AI 100% menggunakan Minimax depth 4 dengan pemangkasan Alpha-Beta.
            </div>
        </div>
    </div>

    <!-- Modal Promosi -->
    <div id="promotion-modal">
        <h3 style="margin-bottom: 10px;">Pilih Promosi</h3>
        <div id="promo-options" style="display: flex; gap: 10px;"></div>
    </div>

    <script>
        /**
         * CORE CHESS LOGIC & ASSETS
         */
        const PIECES = {
            empty: 0,
            wP: 1, wN: 2, wB: 3, wR: 4, wQ: 5, wK: 6,
            bP: 7, bN: 8, bB: 9, bR: 10, bQ: 11, bK: 12
        };

        const PIECE_SVG = {
            wP: '<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" stroke-width="1.5"/></svg>',
            wN: '<svg viewBox="0 0 45 45"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#fff" stroke="#000" stroke-width="1.5"/><path d="M24 18c.38 2.43-1.61 1.24-2.15 1.57-.59.35-.11 1.48.5 1.29 1.07-.35 2.14-.52 2.65-1.14.31-.38.11-1.4-.41-1.92-.37-.36-1.19-.36-1.4-.23-.21.13-.19.43.04.59.23.16.58.16.77.21.19.05.21.37.04.42-.17.05-.33-.2-.54-.23-.21-.03-.47.16-.41.34s.38.12.63.14c.25.02.48.42.25.54-.23.12-.52-.14-.7-.09-.18.05-.2.43.04.53.24.1.61-.1.87-.04.26.06.41.42.22.55-.19.13-.57-.1-.77-.04-.2.06-.2.41.04.51.24.1.61-.1.87-.04.26.06.41.42.22.55-.19.13-.57-.1-.77-.04-.2.06-.2.41.04.51" fill="#fff" stroke="#000" stroke-width="1.5"/></svg>',
            wB: '<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#fff"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .54-3.39-.97-10.11.46-13.5-2-3.39 2.46-10.11 1.03-13.5 2-1.35.45-2.32.43-3-.54 1.35-1.46 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>',
            wR: '<svg viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>',
            wQ: '<svg viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM11 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM38 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z"/><path d="M9 26c0 2 1.5 2 2.5 4 2.5 4 17 4 19.5 4 1 0 2.5-2 2.5-4-8.5-1.5-18.5-1.5-24.5 0z" stroke-linecap="butt"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none"/><path d="M9 39h27v-3H9v3z" stroke-linecap="butt"/></g></svg>',
            wK: '<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5" stroke="#000" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 4.5-11.08c0-2.45-2.02-4.42-4.5-4.42s-4.5 1.97-4.5 4.42c0 3.58 4.5 11.08 4.5 11.08z" fill="#fff" stroke-linecap="butt"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-1-1-4-6-4h-22c-5 0-2 3-6 4-3 6 6 10.5 6 10.5v7z" fill="#fff"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0" stroke="#000"/><path d="M9 39h27v-3H9v3z" fill="#fff" stroke-linecap="butt"/></g></svg>',
            bP: '<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#fff" stroke-width="1.5"/></svg>',
            bN: '<svg viewBox="0 0 45 45"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#000" stroke="#fff" stroke-width="1.5"/><path d="M24 18c.38 2.43-1.61 1.24-2.15 1.57-.59.35-.11 1.48.5 1.29 1.07-.35 2.14-.52 2.65-1.14.31-.38.11-1.4-.41-1.92-.37-.36-1.19-.36-1.4-.23-.21.13-.19.43.04.59.23.16.58.16.77.21.19.05.21.37.04.42-.17.05-.33-.2-.54-.23-.21-.03-.47.16-.41.34s.38.12.63.14c.25.02.48.42.25.54-.23.12-.52-.14-.7-.09-.18.05-.2.43.04.53.24.1.61-.1.87-.04.26.06.41.42.22.55-.19.13-.57-.1-.77-.04-.2.06-.2.41.04.51.24.1.61-.1.87-.04.26.06.41.42.22.55-.19.13-.57-.1-.77-.04-.2.06-.2.41.04.51" fill="#000" stroke="#fff" stroke-width="1.5"/></svg>',
            bB: '<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#000"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .54-3.39-.97-10.11.46-13.5-2-3.39 2.46-10.11 1.03-13.5 2-1.35.45-2.32.43-3-.54 1.35-1.46 3-2 3-2z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>',
            bR: '<svg viewBox="0 0 45 45"><g fill="#000" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>',
            bQ: '<svg viewBox="0 0 45 45"><g fill="#000" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM11 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM38 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z"/><path d="M9 26c0 2 1.5 2 2.5 4 2.5 4 17 4 19.5 4 1 0 2.5-2 2.5-4-8.5-1.5-18.5-1.5-24.5 0z" stroke-linecap="butt"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none"/><path d="M9 39h27v-3H9v3z" stroke-linecap="butt"/></g></svg>',
            bK: '<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5" stroke="#fff" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 4.5-11.08c0-2.45-2.02-4.42-4.5-4.42s-4.5 1.97-4.5 4.42c0 3.58 4.5 11.08 4.5 11.08z" fill="#000" stroke-linecap="butt"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-1-1-4-6-4h-22c-5 0-2 3-6 4-3 6 6 10.5 6 10.5v7z" fill="#000"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0" stroke="#fff"/><path d="M9 39h27v-3H9v3z" fill="#000" stroke-linecap="butt"/></g></svg>'
        };

        const PIECE_VALS = {
            [PIECES.wP]: 10, [PIECES.wN]: 30, [PIECES.wB]: 35, [PIECES.wR]: 50, [PIECES.wQ]: 90, [PIECES.wK]: 1000,
            [PIECES.bP]: -10, [PIECES.bN]: -30, [PIECES.bB]: -35, [PIECES.bR]: -50, [PIECES.bQ]: -90, [PIECES.bK]: -1000
        };

        const PST = {
            pawn: [
                [0, 0, 0, 0, 0, 0, 0, 0],
                [5, 5, 5, 5, 5, 5, 5, 5],
                [1, 1, 2, 3, 3, 2, 1, 1],
                [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],
                [0, 0, 0, 2, 2, 0, 0, 0],
                [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],
                [0.5, 1, 1, -2, -2, 1, 1, 0.5],
                [0, 0, 0, 0, 0, 0, 0, 0]
            ]
        };

        /**
         * CLASS CHESS ENGINE
         */
        class ChessEngine {
            constructor() {
                this.reset();
            }

            reset() {
                this.board = Array(64).fill(0);
                this.setupInitial();
                this.turn = 'white';
                this.castling = { wK: true, wQ: true, bK: true, bQ: true };
                this.enPassant = null;
                this.history = [];
                this.lastMove = null;
                this.gameOver = false;
            }

            setupInitial() {
                const layout = [
                    'bR','bN','bB','bQ','bK','bB','bN','bR',
                    'bP','bP','bP','bP','bP','bP','bP','bP',
                    ...Array(32).fill(null),
                    'wP','wP','wP','wP','wP','wP','wP','wP',
                    'wR','wN','wB','wQ','wK','wB','wN','wR'
                ];
                layout.forEach((p, i) => { if(p) this.board[i] = PIECES[p]; });
            }

            getColor(p) { return p === 0 ? null : (p <= 6 ? 'white' : 'black'); }
            getType(p) { 
                if (p === 0) return null;
                const names = ['P', 'N', 'B', 'R', 'Q', 'K'];
                return names[(p - 1) % 6];
            }

            getLegalMoves(idx, board = this.board) {
                const moves = this.getPseudoMoves(idx, board);
                return moves.filter(m => !this.leavesKingInCheck(m, board));
            }

            getPseudoMoves(idx, board = this.board, attackOnly = false) {
                const piece = board[idx];
                if (piece === 0) return [];
                const color = this.getColor(piece);
                const type = this.getType(piece);
                const r = Math.floor(idx / 8);
                const c = idx % 8;
                let moves = [];

                const add = (tr, tc, spec = null) => {
                    if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                        const tIdx = tr * 8 + tc;
                        const tPiece = board[tIdx];
                        if (tPiece === 0 || this.getColor(tPiece) !== color) {
                            moves.push({ from: idx, to: tIdx, special: spec });
                            return tPiece === 0;
                        }
                    }
                    return false;
                };

                switch (type) {
                    case 'P':
                        const dir = color === 'white' ? -1 : 1;
                        if (!attackOnly) {
                            if (board[(r+dir)*8+c] === 0) {
                                add(r+dir, c);
                                if (((color === 'white' && r === 6) || (color === 'black' && r === 1)) && board[(r+2*dir)*8+c] === 0) add(r+2*dir, c);
                            }
                        }
                        [-1, 1].forEach(dc => {
                            const tc = c + dc;
                            if (tc >= 0 && tc < 8) {
                                const tIdx = (r+dir)*8 + tc;
                                if (board[tIdx] !== 0 && this.getColor(board[tIdx]) !== color) add(r+dir, tc);
                                else if (tIdx === this.enPassant) add(r+dir, tc, 'enPassant');
                            }
                        });
                        break;
                    case 'N':
                        [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(o => add(r+o[0], c+o[1]));
                        break;
                    case 'B':
                        [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(d => { for(let i=1; i<8; i++) if(!add(r+d[0]*i, c+d[1]*i)) break; });
                        break;
                    case 'R':
                        [[-1,0],[1,0],[0,-1],[0,1]].forEach(d => { for(let i=1; i<8; i++) if(!add(r+d[0]*i, c+d[1]*i)) break; });
                        break;
                    case 'Q':
                        [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]].forEach(d => { for(let i=1; i<8; i++) if(!add(r+d[0]*i, c+d[1]*i)) break; });
                        break;
                    case 'K':
                        [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(o => add(r+o[0], c+o[1]));
                        if (!attackOnly && !this.isInCheck(color, board)) {
                            if (color === 'white') {
                                if (this.castling.wK && board[61]===0 && board[62]===0 && !this.isAttacked(61, 'black', board)) moves.push({from:60, to:62, special:'castle'});
                                if (this.castling.wQ && board[59]===0 && board[58]===0 && board[57]===0 && !this.isAttacked(59, 'black', board)) moves.push({from:60, to:58, special:'castle'});
                            } else {
                                if (this.castling.bK && board[5]===0 && board[6]===0 && !this.isAttacked(5, 'white', board)) moves.push({from:4, to:6, special:'castle'});
                                if (this.castling.bQ && board[3]===0 && board[2]===0 && board[1]===0 && !this.isAttacked(3, 'white', board)) moves.push({from:4, to:2, special:'castle'});
                            }
                        }
                        break;
                }
                return moves;
            }

            isAttacked(idx, attackerColor, board = this.board) {
                for (let i = 0; i < 64; i++) {
                    const p = board[i];
                    if (p !== 0 && this.getColor(p) === attackerColor) {
                        const type = this.getType(p);
                        const r = Math.floor(i/8), c = i%8, tr = Math.floor(idx/8), tc = idx%8;
                        if (type === 'P') {
                            if (tr === r + (attackerColor === 'white' ? -1 : 1) && Math.abs(tc - c) === 1) return true;
                        } else if (type === 'K') {
                            if (Math.abs(r-tr) <= 1 && Math.abs(c-tc) <= 1) return true;
                        } else {
                            if (this.getPseudoMoves(i, board, true).some(m => m.to === idx)) return true;
                        }
                    }
                }
                return false;
            }

            isInCheck(color, board = this.board) {
                const kIdx = board.indexOf(color === 'white' ? PIECES.wK : PIECES.bK);
                return kIdx === -1 ? false : this.isAttacked(kIdx, color === 'white' ? 'black' : 'white', board);
            }

            leavesKingInCheck(move, board) {
                const tempBoard = [...board];
                this.execMoveInternal(move, tempBoard);
                return this.isInCheck(this.getColor(board[move.from]), tempBoard);
            }

            execMoveInternal(move, board) {
                const { from, to, special } = move;
                const p = board[from];
                board[to] = p;
                board[from] = 0;
                if (special === 'enPassant') {
                    board[this.getColor(p) === 'white' ? to + 8 : to - 8] = 0;
                } else if (special === 'castle') {
                    if (to === 62) { board[61] = PIECES.wR; board[63] = 0; }
                    else if (to === 58) { board[59] = PIECES.wR; board[56] = 0; }
                    else if (to === 6) { board[5] = PIECES.bR; board[7] = 0; }
                    else if (to === 2) { board[3] = PIECES.bR; board[0] = 0; }
                }
                // Auto promote to Queen for internal sim
                if (this.getType(p) === 'P' && (to < 8 || to >= 56)) {
                    board[to] = this.getColor(p) === 'white' ? PIECES.wQ : PIECES.bQ;
                }
            }

            makeMove(move) {
                this.history.push({
                    board: [...this.board],
                    castling: { ...this.castling },
                    enPassant: this.enPassant,
                    turn: this.turn,
                    lastMove: this.lastMove
                });

                const p = this.board[move.from];
                this.execMoveInternal(move, this.board);

                // Update rights
                if (p === PIECES.wK) this.castling.wK = this.castling.wQ = false;
                if (p === PIECES.bK) this.castling.bK = this.castling.bQ = false;
                if (move.from === 56 || move.to === 56) this.castling.wQ = false;
                if (move.from === 63 || move.to === 63) this.castling.wK = false;
                if (move.from === 0 || move.to === 0) this.castling.bQ = false;
                if (move.from === 7 || move.to === 7) this.castling.bK = false;

                this.enPassant = (this.getType(p) === 'P' && Math.abs(move.from - move.to) === 16) ? (move.from + move.to) / 2 : null;
                this.turn = this.turn === 'white' ? 'black' : 'white';
                this.lastMove = move;
                this.checkStatus();
            }

            undo() {
                if (this.history.length === 0) return;
                const prev = this.history.pop();
                this.board = prev.board;
                this.castling = prev.castling;
                this.enPassant = prev.enPassant;
                this.turn = prev.turn;
                this.lastMove = prev.lastMove;
                this.gameOver = false;
            }

            checkStatus() {
                let hasMove = false;
                for (let i=0; i<64; i++) {
                    if (this.getColor(this.board[i]) === this.turn && this.getLegalMoves(i).length > 0) {
                        hasMove = true; break;
                    }
                }
                if (!hasMove) {
                    this.gameOver = true;
                    return this.isInCheck(this.turn) ? 'checkmate' : 'stalemate';
                }
                return 'ongoing';
            }

            evaluate(board = this.board) {
                let score = 0;
                for (let i=0; i<64; i++) {
                    const p = board[i];
                    if (p === 0) continue;
                    score += PIECE_VALS[p];
                    if (this.getType(p) === 'P') {
                        const r = Math.floor(i/8), c = i%8;
                        score += (this.getColor(p) === 'white' ? PST.pawn[r][c] : -PST.pawn[7-r][c]) * 0.1;
                    }
                }
                return score;
            }

            minimax(depth, alpha, beta, isMax, board) {
                if (depth === 0) return this.evaluate(board);
                
                const turn = isMax ? 'white' : 'black';
                let moves = [];
                for (let i=0; i<64; i++) {
                    if (this.getColor(board[i]) === turn) {
                        this.getLegalMoves(i, board).forEach(m => moves.push(m));
                    }
                }

                if (moves.length === 0) {
                    if (this.isInCheck(turn, board)) return isMax ? -10000 : 10000;
                    return 0;
                }

                if (isMax) {
                    let best = -Infinity;
                    for (const m of moves) {
                        const nb = [...board]; this.execMoveInternal(m, nb);
                        best = Math.max(best, this.minimax(depth-1, alpha, beta, false, nb));
                        alpha = Math.max(alpha, best);
                        if (beta <= alpha) break;
                    }
                    return best;
                } else {
                    let best = Infinity;
                    for (const m of moves) {
                        const nb = [...board]; this.execMoveInternal(m, nb);
                        best = Math.min(best, this.minimax(depth-1, alpha, beta, true, nb));
                        beta = Math.min(beta, best);
                        if (beta <= alpha) break;
                    }
                    return best;
                }
            }
        }

        /**
         * ADVISOR LOGIC
         */
        const engine = new ChessEngine();
        let selectedIdx = null;

        function updateAdvisor() {
            const evalScore = engine.evaluate();
            const textEval = evalScore.toFixed(1);
            const whitePct = 50 + (evalScore * 2); 
            document.getElementById('eval-white').style.width = Math.min(Math.max(whitePct, 5), 95) + '%';
            document.getElementById('eval-black').style.width = (100 - Math.min(Math.max(whitePct, 5), 95)) + '%';
            document.getElementById('eval-text').innerText = (evalScore > 0 ? '+' : '') + textEval + (evalScore > 1 ? " (Putih Unggul)" : evalScore < -1 ? " (Hitam Unggul)" : " (Imbang)");

            // 1. Ancaman (Apa yang bisa dimakan AI giliran ini?)
            const threats = [];
            for (let i=0; i<64; i++) {
                if (engine.getColor(engine.board[i]) === 'white') {
                    if (engine.isAttacked(i, 'black')) {
                        const type = engine.getType(engine.board[i]);
                        const pos = getPosName(i);
                        threats.push(`${type} di ${pos}`);
                    }
                }
            }
            document.getElementById('threat-content').innerHTML = threats.length > 0 ? 
                `AI bisa memakan: <span style="color:var(--danger)">${threats.join(', ')}</span>` : "Pertahanan aman.";

            // 2. Saran Langkah Terbaik (Minimax Deep)
            const suggestions = getTopMoves('white', 3);
            let suggHtml = "";
            suggestions.forEach((s, idx) => {
                suggHtml += `<div class="move-suggestion" onclick="previewMove(${s.move.from}, ${s.move.to})">
                    <span class="move-rank">#${idx+1}</span> ${engine.getType(engine.board[s.move.from])} ${getPosName(s.move.from)} ‚Üí ${getPosName(s.move.to)} 
                    <small style="float:right; color:#888;">Skor: ${s.score.toFixed(1)}</small>
                </div>`;
            });
            document.getElementById('suggestion-content').innerHTML = suggHtml;

            // 3. Prediksi Balasan AI
            if (suggestions.length > 0) {
                const bestPlayerMove = suggestions[0].move;
                const tempBoard = [...engine.board];
                engine.execMoveInternal(bestPlayerMove, tempBoard);
                
                // Cari balasan terbaik Hitam di board simulasi
                let bestCounter = null;
                let worstScore = Infinity;
                for (let i=0; i<64; i++) {
                    if (engine.getColor(tempBoard[i]) === 'black') {
                        engine.getLegalMoves(i, tempBoard).forEach(m => {
                            const score = engine.evaluate(tempBoard); // Simple eval
                            if (score < worstScore) { worstScore = score; bestCounter = m; }
                        });
                    }
                }
                if (bestCounter) {
                    document.getElementById('prediction-content').innerText = 
                        `Jika Anda ke ${getPosName(bestPlayerMove.to)}, AI kemungkinan akan membalas dengan ${engine.getType(tempBoard[bestCounter.from])} ke ${getPosName(bestCounter.to)}.`;
                }
            }
        }

        function getTopMoves(color, count) {
            let moves = [];
            for (let i=0; i<64; i++) {
                if (engine.getColor(engine.board[i]) === color) {
                    engine.getLegalMoves(i).forEach(m => {
                        const nb = [...engine.board];
                        engine.execMoveInternal(m, nb);
                        const score = engine.minimax(3, -10000, 10000, color==='black', nb);
                        moves.push({ move: m, score: score });
                    });
                }
            }
            moves.sort((a, b) => color === 'white' ? b.score - a.score : a.score - b.score);
            return moves.slice(0, count);
        }

        function getPosName(idx) {
            return 'abcdefgh'[idx % 8] + (8 - Math.floor(idx/8));
        }

        /**
         * UI CONTROLLER
         */
        function render() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            const kingInCheckIdx = engine.isInCheck(engine.turn) ? engine.board.indexOf(engine.turn === 'white' ? PIECES.wK : PIECES.bK) : -1;

            for (let i=0; i<64; i++) {
                const sq = document.createElement('div');
                sq.className = `square ${(Math.floor(i/8) + i%8)%2===0 ? 'light' : 'dark'}`;
                
                if (engine.lastMove && (i === engine.lastMove.from || i === engine.lastMove.to)) sq.classList.add('last-move');
                if (i === selectedIdx) sq.classList.add('selected');
                if (i === kingInCheckIdx) sq.classList.add('check');
                
                // Risk Map: Highlight pieces under attack by black
                if (engine.getColor(engine.board[i]) === 'white' && engine.isAttacked(i, 'black')) sq.classList.add('threatened');

                const p = engine.board[i];
                if (p !== 0) {
                    const name = Object.keys(PIECES).find(k => PIECES[k] === p);
                    const pDiv = document.createElement('div');
                    pDiv.className = 'piece';
                    pDiv.innerHTML = PIECE_SVG[name];
                    sq.appendChild(pDiv);
                }

                if (selectedIdx !== null) {
                    if (engine.getLegalMoves(selectedIdx).some(m => m.to === i)) {
                        const dot = document.createElement('div');
                        dot.className = 'legal-dot';
                        sq.appendChild(dot);
                    }
                }

                sq.onclick = () => onSquareClick(i);
                boardEl.appendChild(sq);
            }

            const status = engine.checkStatus();
            const disp = document.getElementById('status-display');
            if (status === 'checkmate') {
                disp.innerText = "SKAKMAT! " + (engine.turn === 'white' ? "HITAM MENANG" : "PUTIH MENANG");
                disp.style.background = "var(--danger)";
            } else if (status === 'stalemate') {
                disp.innerText = "STALEMATE (SERI)";
            } else {
                disp.innerText = "Giliran: " + (engine.turn === 'white' ? "Putih" : "Hitam") + (engine.isInCheck(engine.turn) ? " (SKAK!)" : "");
                disp.style.background = "#111";
            }

            updateAdvisor();

            if (!engine.gameOver && engine.turn === 'black') {
                setTimeout(makeAIMove, 600);
            }
        }

        function onSquareClick(idx) {
            if (engine.gameOver || engine.turn === 'black') return;

            if (selectedIdx === null) {
                if (engine.getColor(engine.board[idx]) === 'white') selectedIdx = idx;
            } else {
                const move = engine.getLegalMoves(selectedIdx).find(m => m.to === idx);
                if (move) {
                    if (engine.getType(engine.board[selectedIdx]) === 'P' && (idx < 8 || idx >= 56)) {
                        openPromotion(move);
                    } else {
                        engine.makeMove(move);
                        selectedIdx = null;
                    }
                } else {
                    selectedIdx = engine.getColor(engine.board[idx]) === 'white' ? idx : null;
                }
            }
            render();
        }

        function makeAIMove() {
            // Level 100% menggunakan minimax depth 4
            const best = getTopMoves('black', 1)[0];
            if (best) {
                engine.makeMove(best.move);
                render();
            }
        }

        function openPromotion(move) {
            const modal = document.getElementById('promotion-modal');
            const container = document.getElementById('promo-options');
            container.innerHTML = '';
            ['Q','R','N','B'].forEach(type => {
                const btn = document.createElement('div');
                btn.style.width = '60px'; btn.style.height = '60px'; btn.style.cursor = 'pointer';
                btn.innerHTML = PIECE_SVG[engine.turn[0] + type];
                btn.onclick = () => {
                    engine.makeMove(move);
                    engine.board[move.to] = PIECES[engine.turn[0] === 'w' ? 'b' + type : 'w' + type]; // fix reversed turn
                    modal.style.display = 'none';
                    selectedIdx = null;
                    render();
                };
                container.appendChild(btn);
            });
            modal.style.display = 'block';
        }

        function previewMove(f, t) {
            selectedIdx = f;
            render();
        }

        function resetGame() {
            if(confirm("Mulai ulang permainan?")) {
                engine.reset();
                selectedIdx = null;
                render();
            }
        }

        function undoMove() {
            engine.undo(); // Batal AI
            engine.undo(); // Batal Player
            selectedIdx = null;
            render();
        }

        window.onload = render;
    </script>
</body>
      </html>
